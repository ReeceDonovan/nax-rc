\lstset{language=bash}
\newpage
\chapter{Design} % (30-40 pages)
\label{chap:design}
This chapter examines various data structures and algorithms with key aspects that may make them suitable for incorporation into a \lstinline{Version Control System}. We also assess what metrics are relevant to facilitate the comparison of these data structures and algorithms.

% 
% % TODO: Reconsider the formatting of this introduction
% In this chapter, we examine various data structures and algorithms with key aspects that may make them suitable for incorporation into a \lstinline{Version Control System}.\\
% % TODO: Decide whether to include this paragraph or not due to the top paragraph of the "Data Structures" section (see below)
% % \\This examination evaluates several alternative data structures, including \lstinline{Linked Lists}, \lstinline{Binary Trees}, \lstinline{Hash Tables}, and \lstinline{Directed Acyclic Graphs (DAGs)}, focusing on their operational efficiency, structural properties, and implementation considerations.
% % Furthermore, algorithms for functionality such as \lstinline{Traversal} and \lstinline{Difference (Diffing)} are analyzed in terms of their computational complexity, conceptual simplicity, and implementation considerations.\\\\
% % Finally, the chapter also assesses what metrics are relevant to facilitate the comparison of these data structures and algorithms.
% We also assess what metrics are relevant to facilitate the comparison of these data structures and algorithms.
% 
% ------------------------------------------------------------------------------
% 
% TODO: Change title
\section{Data Structures}
% Data Structures
% ---------------
% TODO: Add references
Data structures are objects that can be used to store, organize, and manipulate large amounts of data. They play a crucial role in computer science and are fundamental building blocks of many software systems, including \lstinline{Version Control Systems}. The choice of data structure is critical to the overall performance and scalability of a \lstinline{Version Control System}.
\smallskip

In order to evaluate the suitability of a data structure for implementation in a \lstinline{Version Control System}, it is necessary to consider several core aspects. Firstly, \lstinline{operational efficiency}, which refers to the time and space complexity of the basic operations performed by the data structure, is a crucial consideration. The efficiency of these operations can have a significant impact on the overall performance of the \lstinline{Version Control System}.
\smallskip

Another important aspect is the data structure's \lstinline{structural specificity}, which encompasses how data is stored and organized within the structure. This is critical because the structural specifics can affect the ease of implementation and the ability to efficiently perform operations such as \lstinline{insertions}, \lstinline{deletions}, and \lstinline{updates}.
\smallskip

Lastly, the \lstinline{implementation details} must be considered, including the ease of implementation and compatibility with the programming language. A data structure that is straightforward to implement and easy to maintain/iterate upon will result in a more streamlined and efficient \lstinline{Version Control System}.
% 
% What are the potential data structures that could be used?
%  - Explain the data structures in detail - (4 x 2 page)
%  - Explain the pros and cons of each data structure - (4 x 0.5 page)
%  - Explain how each data structure will be implemented - (4 x 1 page)
% 
% TODO: Add references
\subsection{Linked List}
\label{sec:linked-list}
% ------------------------------------------------------------------------------
% TODO: Add explanation of why a linked list is suitable for a Version Control System
% ------------------------------------------------------------------------------
A \lstinline{Linked List} is a linear collection of data elements, called nodes, each pointing to the next node by means of a pointer. The \lstinline{Linked List} is the most sought-after data structure when it comes to handling dynamic data elements \cite{ravikiran_2022}.
\smallskip

There are two main types of \lstinline{Linked Lists}: \nameref{par:singly-linked-list} and \nameref{par:doubly-linked-list}, but we will only be considering the \nameref{par:doubly-linked-list} when we reach the \nameref{chap:implementation} chapter.
% TODO: Fix spacing between these two paragraphs
% There are two types of \lstinline{Linked Lists}:
\paragraph{Singly-linked lists (SLL)}
\label{par:singly-linked-list}
% Singly-Linked List Definition
\begin{itemize}
    \item \lstinline{SLL} nodes contain two fields: \lstinline{data} field and \lstinline{next} pointer field.
    \item Traversal of a \lstinline{SLL} can be done using the \lstinline{next} pointer field only. Meaning, the \lstinline{SLL} can be traversed in only one direction, from the first node to the last node.
    \item The \lstinline{SLL} occupies less memory than a \lstinline{DLL} because it does not contain a \lstinline{prev} pointer field.
    \item \lstinline{SLL} is preferred over \lstinline{DLL} when it comes to the execution of stack and queue operations.
    \item \lstinline{SLL} is also preferred over \lstinline{DLL} to save memory when a searching operation is not required.
\end{itemize}
% Singly-Linked List Efficiency Analysis
\begin{table}[h]
    \centering
    \caption{Efficiency Analysis of Singly-Linked List Operations}
    \label{tab:singly-linked-list-efficiency-analysis}
    \begin{tabular}{|c|c|c|}
        \hline
        Operation           & Worst Case & Average Case \\ \hline
        Access              & $O(n)$     & $O(n)$       \\ \hline
        Search              & $O(n)$     & $O(n)$       \\ \hline
        % Insert              & $O(n)$     & $O(1)$       \\ \hline
        % Delete              & $O(n)$     & $O(n)$       \\ \hline
        Insert (at Head)    & $O(1)$     & $O(1)$       \\ \hline
        Delete (at Head)    & $O(1)$     & $O(1)$       \\ \hline
        Insert (at Current) & $O(1)$     & $O(1)$       \\ \hline
        Delete (at Current) & $O(1)$     & $O(1)$       \\ \hline
        Insert (at Tail)    & $O(n)$     & $O(n)$       \\ \hline
        Delete (at Tail)    & $O(n)$     & $O(n)$       \\ \hline
    \end{tabular}
\end{table}
% Singly-Linked List Diagram
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.9\textwidth]{singly-linked-list.png}
    \caption{Singly Linked List (SLL) \cite{vaghani_2023}}
    \label{fig:singly-linked-list}
\end{figure}
\hfill\medskip\\

\paragraph{Doubly-linked lists (DLL)}
\label{par:doubly-linked-list}
% Doubly-Linked List Definition
\begin{itemize}
    \item \lstinline{DLL} nodes contain three fields: \lstinline{data} field, \lstinline{prev} pointer field and \lstinline{next} pointer field.
    \item Traversal of a \lstinline{DLL} can be done using the \lstinline{next} pointer field or the \lstinline{prev} pointer field. Meaning, the \lstinline{DLL} can be traversed in both directions, from the first node to the last node and vice versa.
    \item The \lstinline{DLL} occupies more memory than a \lstinline{SLL} because it contains a \lstinline{prev} pointer field.
\end{itemize}

% Doubly-Linked List Efficiency Analysis
% \begin{table}[h]
\begin{table}[h]
    \centering
    \caption{Efficiency Analysis of Doubly-Linked List Operations}
    \label{tab:doubly-linked-list-efficiency-analysis}
    \begin{tabular}{|c|c|c|}
        \hline
        Operation           & Worst Case & Average Case \\ \hline
        Access              & $O(n)$     & $O(n)$       \\ \hline
        Search              & $O(n)$     & $O(n)$       \\ \hline
        % Insert              & $O(n)$     & $O(n)$       \\ \hline
        % Delete              & $O(n)$     & $O(n)$       \\ \hline
        Insert (at Head)    & $O(1)$     & $O(1)$       \\ \hline
        Delete (at Head)    & $O(1)$     & $O(1)$       \\ \hline
        Insert (at Current) & $O(1)$     & $O(1)$       \\ \hline
        Delete (at Current) & $O(1)$     & $O(1)$       \\ \hline
        Insert (at Tail)    & $O(1)$     & $O(1)$       \\ \hline
        Delete (at Tail)    & $O(1)$     & $O(1)$       \\ \hline
    \end{tabular}
\end{table}

% Doubly-Linked List Diagram
\begin{figure}[!htbp]
    \centering
    \includegraphics[width=1.1\textwidth]{doubly-linked-list.png}
    \caption{Doubly Linked List (DLL) \cite{vaghani_2023}}
    \label{fig:doubly-linked-list}
\end{figure}
\hfill\medskip\\

% TODO: Check positioning of the figure
\newpage

\paragraph{Advantages}
\begin{itemize}
    \item Efficient insertion and deletion operations at the beginning, end, and middle of the list.
    \item Easy traversal in both directions, allowing for simpler and more flexible algorithms.
    \item Dynamic size, allowing the list to grow and shrink as needed during runtime.
    \item No need for contiguous memory allocation, which allows for better memory utilisation.
    \item Simplified implementation compared to more complex data structures.
\end{itemize}
\paragraph{Disadvantages}
\begin{itemize}
    \item Higher memory overhead due to the storage of two pointers for each node.
    \item Slower random access compared to arrays or hash tables, as elements must be traversed sequentially.
    \item No inherent support for efficient searching, leading to linear search times.
\end{itemize}

\paragraph{Summary}
\hfill\medskip\\
A \lstinline{Doubly Linked List} could be used as the core data structure, but it has some limitations. The sequential nature of the data structure makes it easy to maintain a linear history of changes and revert to previous versions. However, the lack of efficient searching and random access capabilities can slow down operations when dealing with large repositories or complex branching scenarios.

% 
% TODO: Add references
% Advantages and Disadvantages in the context of a Version Control System
% \paragraph{Advantages}
% \begin{itemize}
%     \item Dynamic size: As new versions of a file are created, the \lstinline{Linked List} can grow in size to accommodate the new data, without the need to pre-allocate memory.
%     \item Efficient storage of file changes: Each node in the \lstinline{Linked List} can store the entire contents of a file version, along with metadata such as the date and time the change was made. This allows for efficient storage of file changes over time.
%     \item Easy traversal of file history: The \lstinline{Linked List} structure allows for easy traversal of the file history, as each node contains a reference to the previous version of the file. This makes it easy to track changes and revert to previous versions of a file.
%     \item Memory efficient: The \lstinline{Linked List} structure is memory efficient, as each node only contains the current version of the file and changes made to it, along with simple references to the next and previous nodes in the list. This means that the \lstinline{Linked List} structure does not need to store the entire file history in memory, which can be a significant amount of data.
% \end{itemize}
% \paragraph{Disadvantages}
% \begin{itemize}
%     \item Inefficient retrieval of specific file versions: Retrieving a specific version of a file can be slow, as the \lstinline{Linked List} structure does not allow for random access to the file history. This means that the entire file history must be traversed from the most recent version of the file to the desired version.
%     \item Limited scalability: For large file histories, the \lstinline{Linked List} structure can be less efficient and will not scale as well as other data structures.
%     \item Extra memory overhead: Each node in the \lstinline{Linked List} structure contains a reference to the next and previous nodes in the list, which can add up when dealing with large file histories.
%     \item Not suitable for concurrent access: The \lstinline{Linked List} structure is not suitable for concurrent access, as it is not thread-safe and can lead to data corruption and race conditions.
% \end{itemize}

% % TODO: Add references
% \paragraph{Summary}
% A \lstinline{Doubly-Linked List} is a data structure that consists of a sequence of nodes, each node having a data field and two pointers, one pointing to the next node in the list and the other pointing to the previous node.

% One of the main advantages of using a \lstinline{Doubly-Linked List} is that it allows for easy insertion and deletion of nodes, making it possible to add new file versions or remove outdated ones easily.

% However, Concurrent access to a \lstinline{Doubly-Linked List} can lead to data inconsistencies and race conditions, and proper synchronization must be implemented to prevent these issues.
% \newpage
\subsection{Binary Tree}
% ------------------------------------------------------------------------------
% TODO: Add explanation of why a binary tree is suitable for a Version Control System
% ------------------------------------------------------------------------------
% A \lstinline{Binary Tree} is a hierarchical data structure that consists of a set of nodes, where each node can have at most two children. The topmost node in the tree is called the root node, and the nodes that do not have any children are called leaf nodes. The nodes that have children are called internal nodes. The \lstinline{Binary Tree} structure is a special case of the \lstinline{Tree} data structure, where each node can have at most two children.

A \lstinline{Binary Tree} is a hierarchical data structure in which each node has at most two child nodes, arranged in a way that the value of the node to the left is less than or equal to the parent node and the value of the node to the right is greater than or equal to the parent node. This ordering property ensures efficient search, insertion, and deletion operations. There are several types of binary trees, such as \lstinline{binary search trees}, \lstinline{AVL trees}, and \lstinline{red-black trees}, each with different balancing mechanisms to maintain tree height and performance.

Each node in a \lstinline{Binary Tree} contains the following elements:
\begin{enumerate}
    \item Data: The data stored in the node.
    \item Left child: A pointer to the left child node.
    \item Right child: A pointer to the right child node.
\end{enumerate}

% % TODO: Add references/Confirm this is correct
% There are several different types of \lstinline{Binary Tree} structures, including:
% \begin{enumerate}
%     \item Full Binary Tree: A \lstinline{Binary Tree} where each node has either zero or two children.
%     \item Complete Binary Tree: A \lstinline{Binary Tree} where all levels of the tree are completely filled, except for the last level. The last level of the tree is filled from left to right.
%     \item Balanced Binary Tree: A \lstinline{Binary Tree} where the difference between the height of the left and right subtrees of any node is not greater than one.
%     \item Degenerate (or Pathological) Binary Tree: A \lstinline{Binary Tree} that is not balanced, where the height of the tree is equal to the number of nodes in the tree.
% \end{enumerate}

% Binary Tree Efficiency Analysis
\begin{table}[h]
    \centering
    \caption{Efficiency Analysis of Binary Tree Operations}
    \label{tab:binary-tree-efficiency-analysis}
    \begin{tabular}{|c|c|c|}
        \hline
        Operation & Worst Case & Average Case \\ \hline
        Search    & $O(n)$     & $O(\log n)$  \\ \hline
        Insert    & $O(n)$     & $O(\log n)$  \\ \hline
        Delete    & $O(n)$     & $O(\log n)$  \\ \hline
    \end{tabular}
\end{table}
% TODO: Add image of binary tree data structure
\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{binary-tree.png}
    \caption{Binary Tree \cite{mcmahon_2020}}
    \label{fig:binary-tree}
\end{figure}
\newpage
% TODO: Add binary tree detailed efficiency analysis of each operation

\paragraph{Advantages}
\begin{itemize}
    \item Efficient search, insertion, and deletion operations when the tree is balanced.
    \item Hierarchical structure allows for natural representation of hierarchical relationships or data with partial order.
    \item Can be easily traversed in various orders (e.g., inorder, preorder, and postorder) to suit different needs.
    \item No need for contiguous memory allocation, which allows for better memory utilisation.
    \item Provides the foundation for more advanced tree structures, like B-trees or trie, that can be used for advanced indexing or searching.
\end{itemize}
\paragraph{Disadvantages}
\begin{itemize}
    \item Unbalanced trees can lead to degraded performance.
    \item Requires more memory overhead compared to linear data structures due to the storage of pointers for each node.
    \item Less suitable for representing non-hierarchical or unordered data.
    \item Can be more complex to implement and maintain compared to simpler data structures.
\end{itemize}

\paragraph{Summary}
\hfill\medskip\\
A \lstinline{Binary Tree} could be used as the core data structure, but it may not be the most suitable choice due to its hierarchical nature. While it can efficiently store and manage version history when dealing with linear or partially ordered data, version control systems often require support for complex branching and merging scenarios, which may not be well-suited for a binary tree.
\smallskip

Additionally, the need for balancing mechanisms to maintain tree height and performance can add complexity to the implementation and maintenance of the system. \lstinline{Directed Acyclic Graphs} or other more advanced data structures might be more appropriate for handling complex functionality.

% % TODO: Add references
% % Advantages and Disadvantages in the context of a Version Control System
% \paragraph{Advantages}
% \begin{itemize}
%     \item Efficient storage of file changes: Each node in the \lstinline{Binary Tree} structure can store the entire contents of a file version, along with metadata such as the date and time the version was created. This allows for efficient storage of file changes, as the entire file history can be stored in a single \lstinline{Binary Tree} structure.
%     \item Easy traversal of file history: The \lstinline{Binary Tree} structure allows for easy traversal of the file history, with the root node representing the most recent version of the file and the leaf nodes representing the oldest versions of the file. This makes it easy to track changes and revert to previous versions of the file.
%     \item Flexibility: \lstinline{Binary Tree} structures can be used to implement a variety of other data structures, such as \lstinline{Binary Search Trees}, \lstinline{AVL Trees}, \lstinline{Heaps}, and others, which can be useful for other operations in a \lstinline{Version Control System}.
% \end{itemize}
% % TODO: Confirm this is correct
% \paragraph{Disadvantages}
% \begin{itemize}
%     \item Inefficient retrieval of specific file versions: The \lstinline{Binary Tree} structure can be slow when retrieving specific file versions, as it requires traversing the \lstinline{Binary Tree} to find the desired node. This can be inefficient when dealing with large file histories.
%     \item Limited scalability: For large file histories, the \lstinline{Binary Tree} structure can be less efficient and may not scale as well as other data structures.
%     \item Extra memory overhead: Each node in the \lstinline{Binary Tree} structure requires extra memory to store the pointers to the left and right child nodes. This can become significant when dealing with large file histories.
%     \item Unbalanced trees can lead to poor performance: If the \lstinline{Binary Tree} structure becomes skewed, the time complexity of searching, insertion, and deletion operations can become \lstinline{O(n)}, where \lstinline{n} is the number of nodes in the tree.
%     \item Not suitable for concurrent access: The \lstinline{Binary Tree} structure is not suitable for concurrent access, as it is not thread-safe. This can lead to data corruption and race conditions.
% \end{itemize}

\subsection{Hash Table}
% ------------------------------------------------------------------------------
% TODO: Add explanation of why a hash table is suitable for a Version Control System
% ------------------------------------------------------------------------------

% A \lstinline{Hash Table} is a data structure that provides an efficient way to store and retrieve key-value pairs. It uses a hash function to map each key to an index in an underlying array, where the corresponding value is stored. When the hash function distributes keys uniformly across the array, hash tables can provide constant-time average-case performance for search, insertion, and deletion operations. In addition, various techniques can be employed to handle collisions (when two keys map to the same index), such as chaining or open addressing.

A \lstinline{Hash Table} is a data structure that uses a hash function to map keys to their corresponding values. It is an efficient way to implement an associative array, where keys are used to look up values.
\smallskip

The basic idea behind a \lstinline{Hash Table} is to use a hash function to map a key to an index in an array, called a bucket, where the corresponding value can be found or stored. The process of mapping a key to an index is called \lstinline{hashing}.
\smallskip

Each element in a \lstinline{Hash Table} consists of:
\begin{enumerate}
    \item Key: This is the value used to look up a corresponding element in the \lstinline{Hash Table}.
    \item Value: This is the value associated with the key that is stored in the \lstinline{Hash Table}.
\end{enumerate}

% TODO: Add references
When a new element is added to a \lstinline{Hash Table}, the key is passed through a \lstinline{hash} function which produces an \lstinline{index} (also called a hash value or bucket) where the element is stored.
When a value is to be retrieved, the key is passed through the same hash function, and the resulting \lstinline{index} is used to look up the corresponding value in the \lstinline{Hash Table}.

% Hash Table Efficiency Analysis
\begin{table}[h]
    \centering
    \caption{Efficiency Analysis of Hash Table Operations}
    \label{tab:hash-table-efficiency-analysis}
    \begin{tabular}{|c|c|c|}
        \hline
        Operation & Worst Case & Average Case \\ \hline
        Search    & $O(n)$     & $\Theta(1)$  \\ \hline
        Insert    & $O(n)$     & $\Theta(1)$  \\ \hline
        Delete    & $O(n)$     & $\Theta(1)$  \\ \hline
    \end{tabular}
\end{table}
% Image of hash table data structure
\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{hash-table.png}
    \caption{Hash Table \cite{stemmler_2022}}
    \label{fig:hash-table}
\end{figure}
\newpage
% TODO: Add hash table detailed efficiency analysis of each operation

\paragraph{Advantages}
\begin{itemize}
    \item Fast average-case performance for search, insertion, and deletion operations.
    \item Supports efficient key-based lookups and direct access to values.
    \item Can be easily resized to accommodate a growing number of key-value pairs, maintaining constant-time complexity.
    \item Suitable for storing unordered or non-hierarchical data.
    \item Provides a foundation for more advanced data structures, like distributed hash tables or bloom filters, used in various applications.
\end{itemize}
\paragraph{Disadvantages}
\begin{itemize}
    \item Requires a good hash function to ensure uniform key distribution and avoid performance degradation due to collisions.
    \item Higher memory overhead compared to linear data structures, as the underlying array needs to be larger than the number of stored key-value pairs to maintain performance.
    \item No inherent support for ordered traversal or range queries, as keys are not stored in a sorted manner.
\end{itemize}

\paragraph{Summary}
\hfill\medskip\\
While \lstinline{Hash Tables} can provide fast and efficient key-based lookups, they may not be the most suitable data structure for the core of a \lstinline{Version Control System}. The lack of inherent support for ordered traversal or range queries can make it difficult to efficiently handle complex branching and merging scenarios that are common in version control systems.
\smallskip

\lstinline{Directed Acyclic Graphs} or other more advanced data structures are often better suited for handling complex branching and merging operations, as they can provide more efficient support for ordered traversal and range queries. Additionally, Version Control Systems typically need to maintain relationships between revisions, which is not a natural fit for the unordered nature of hash tables.
\smallskip

In summary, although \lstinline{Hash Tables} can provide fast key-based lookups and efficient performance in certain scenarios, they may not be the most suitable or scalable choice for the core data structure of a version control system due to their unordered nature and lack of support for ordered traversal or range queries.

% TODO: Add references
% Advantages and Disadvantages in the context of a Version Control System
% \paragraph{Advantages}
% \begin{itemize}
%     \item Efficient searching, insertion, and deletion: A well-implemented \lstinline{Hash Table} allows for these operations to be performed in \lstinline{O(1)} time, which is useful for a Version Control System as it needs to be able to quickly retrieve, insert, and delete file versions.
%     \item Dynamic resizing: \lstinline{Hash Tables} can grow or shrink in size as needed, which is useful for a Version Control System as the number of file versions can vary greatly.
%           % TODO: Confirm that this is true
%     \item Low overhead: A \lstinline{Hash Table} only requires a small amount of overhead for pointers and the hash function, and thus uses less memory than an array or a \lstinline{Linked List} with the same number of elements.
% \end{itemize}
% \paragraph{Disadvantages}
% \begin{itemize}
%     \item{Hash collisions: \lstinline{Hash} functions can produce collisions, where two different keys produce the same \lstinline{index}, leading to the same location in the \lstinline{Hash Table}.}
%     \begin{itemize}
%         \item{\lstinline{Collision resolution techniques}, such as \lstinline{open addressing} and \lstinline{separate chaining}, can be used to handle collisions but it still increases the time complexity of the \lstinline{Hash Table} operations.}
%     \end{itemize}
%     \item Clustering: When all the elements in a \lstinline{Hash Table} are stored in the same bucket, it is called \lstinline{clustering}. This can lead to a performance degradation leading the \lstinline{Hash Table} operations to have the worst-case time complexity of \lstinline{O(n)} for insertion, deletion, and retrieval.
% \end{itemize}

\subsection{Directed Acyclic Graph (DAG)}
% ------------------------------------------------------------------------------
% TODO: Add explanation of why a DAG is suitable for a Version Control System
% ------------------------------------------------------------------------------

A \lstinline{Directed Acyclic Graph (DAG)} is a data structure that consists of nodes connected by directed edges, forming a graph with no cycles. This means that it is impossible to start at a node and follow a sequence of directed edges that leads back to the same node. DAGs are particularly useful for representing dependencies, partial orders, or processes that have a specific sequence of events. For example, in the context of a version control system, a DAG can be used to represent the history of changes made to a project, with nodes representing commits and edges representing parent-child relationships between commits.

% A \lstinline{Directed Acyclic Graph (DAG)} is a type of graph that consists of a set of nodes and directed edges between pairs of nodes. The edges have direction and they connect one node to another.
% Unlike in a \lstinline{Tree} structure, in a \lstinline{DAG}, a node can have multiple parents and multiple children, but there cannot be any cycles in the graph.

% A node in a \lstinline{DAG} can represent any type of data, and the edges can represent any type of relationship between the nodes. Each node in a \lstinline{DAG} contains the following elements:
% \begin{enumerate}
%     \item Data: The data that the node represents.
%     \item Adjacency list: A list of the nodes that are connected to the current node by an edge.
% \end{enumerate}

% TODO: Add DAG detailed efficiency analysis of each operation
% Directed Acyclic Graph (DAG) Efficiency Analysis
% \begin{table}[h]
%     \centering
%     \caption{Efficiency Analysis of Directed Acyclic Graph (DAG) Operations}
%     % TODO: Create a table of the efficiency analysis of the DAG operations !IMPORTANT!
%     \label{tab:dag-efficiency-analysis}
%     \begin{tabular}{|c|c|c|}
%         \hline
%         Operation & Worst Case & Average Case \\ \hline
%         % Search    & $O(n)$     & $\Theta(1)$  \\ \hline
%         % Insert    & $O(n)$     & $\Theta(1)$  \\ \hline
%         % Delete    & $O(n)$     & $\Theta(1)$  \\ \hline
%     \end{tabular}
% \end{table}
% Image of DAG data structure
\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{dag.png}
    \caption{Directed Acyclic Graph (DAG) \cite{surti_2016}}
    \label{fig:dag}
\end{figure}
\newpage

\paragraph{Advantages}
\begin{itemize}
    \item Efficiently represents complex branching and merging scenarios common in Version Control Systems.
    \item Can naturally model dependencies, partial orders, or processes with a specific sequence of events.
    \item Enables efficient algorithms for topological sorting, which can be useful for ordering commits or resolving dependencies.
    \item No need for contiguous memory allocation, which allows for better memory utilisation.
    \item Provides a more expressive and flexible data structure compared to linear or hierarchical structures, making it suitable for various applications.
\end{itemize}
\paragraph{Disadvantages}
\begin{itemize}
    \item Can be more complex to implement and maintain compared to simpler data structures.
    \item Requires more memory overhead compared to linear data structures due to the storage of multiple pointers for each node.
    \item Finding the shortest or most efficient path between nodes can be computationally expensive in large graphs.
    \item No inherent support for fast key-based lookups or direct access to values, as nodes are not indexed by a specific key.
\end{itemize}

\paragraph{Summary}
\hfill\medskip\\
% TODO: Update this summary
\lstinline{Directed Acyclic Graphs} are particularly well-suited for use as the core data structure in a version control system. Their ability to efficiently represent complex branching and merging scenarios allows for more expressive and flexible management of project history. Additionally, the natural modelling of dependencies and partial orders enables efficient algorithms for tasks such as topological sorting and dependency resolution, which are common in version control systems. Overall, the advantages of DAGs in representing complex relationships and dependencies make them a suitable and scalable choice for the core data structure of a version control system.

% % TODO: Add references
% % Advantages and Disadvantages in the context of a Version Control System
% \paragraph{Advantages}
% \begin{itemize}
%     \item Representing complex relationships: \lstinline{DAGs} can be useful for representing complex relationships between different versions of a file, such as \lstinline{branching} and \lstinline{merging} of changes.
%           % TODO: Reconsider this point
%     \item Representing multiple paths: \lstinline{DAGs} can be used to represent multiple paths or multiple possibilities of how a file can change over time.
%           % TODO: Reconsider this point
%     \item Flexibility: \lstinline{DAGs} are very flexible and can be used to represent any type of data and any type of relationship between the data.
% \end{itemize}
% \paragraph{Disadvantages}
% \begin{itemize}
%     \item Complex traversal: Traversing a \lstinline{DAG} can be more complex than traversing a \lstinline{Tree} because there can be multiple paths to traverse, which makes it more difficult to retrieve specific versions of a file.
%     \item Limited scalability: \lstinline{DAGs} may not scale well for large file histories and a large number of versions because they can become very complex and difficult to traverse.
%     \item Not good for searching, insertion, and deletion: \lstinline{DAGs} are not good for searching, insertion, and deletion because they are not ordered and they do not have a root node. This means that the time complexity of these operations is \lstinline{O(n)} due to the need to traverse the entire graph.
% \end{itemize}

% ------------------------------------------------------------------------------

% Algorithms
% ---------------
% What is the essential core functionality of the VCS? (Traversal/Searching, Hashing, Diffing, etc.) - (0.5 page)
% For each functionality, what are the different algorithms that could be used?
% - Explain the algorithms in detail - ((3 x 2) x 1.5 = 9 page)
% - Explain the pros and cons of each algorithm - ((3 x 2) x 0.5 = 3 page)
% - Explain how each algorithm will be implemented - ((3 x 2) x 1 = 6 page)

% What data structures pair well with each algorithm? - (2 page)

% What metrics are important regarding each data structure and algorithm?

% ------------------------------------------------------------------------------

\section{Algorithms}

% TODO: Add intro paragraph



% TODO: Explain the core functionality of the VCS that require algorithms (Traversal/Searching, Hashing, Diffing, etc.)

% ------------------------------------------------------------------------------

\subsection{Traversal}

% TODO: Explain what traversal is and why it is important in a VCS

% TODO: Fill in !important
\subsubsection{Depth First Search (DFS)}

% TODO: Add references
% Advantages and Disadvantages in the context of a Version Control System
% TODO: Fill in !important
\paragraph{Advantages}
% TODO: Fill in !important
\paragraph{Disadvantages}

% TODO: Add implementation details
\paragraph{Implementation Details}

% TODO: Summary of the suitability of the algorithm in the context of a Version Control System
\paragraph{Summary}

% TODO: Fill in !important
\subsubsection{Breadth First Search (BFS)}

% TODO: Add references
% Advantages and Disadvantages in the context of a Version Control System
% TODO: Fill in !important
\paragraph{Advantages}
% TODO: Fill in !important
\paragraph{Disadvantages}

% TODO: Add implementation details
\paragraph{Implementation Details}

% TODO: Summary of the suitability of the algorithm in the context of a Version Control System
\paragraph{Summary}

% ------------------------------------------------------------------------------

\subsection{Hashing}

% TODO: Explain what hashing is and why it is important in a VCS

% TODO: Fill in !important
\subsubsection{SHA-2}

% TODO: Add references
% Advantages and Disadvantages in the context of a Version Control System
% TODO: Fill in !important
\paragraph{Advantages}
% TODO: Fill in !important
\paragraph{Disadvantages}

% TODO: Add implementation details
\paragraph{Implementation Details}

% TODO: Summary of the suitability of the algorithm in the context of a Version Control System
\paragraph{Summary}


% TODO: Fill in !important
\subsubsection{Rabin-Karp Algorithm}

% TODO: Add references
% Advantages and Disadvantages in the context of a Version Control System
% TODO: Fill in !important
\paragraph{Advantages}
% TODO: Fill in !important
\paragraph{Disadvantages}

% TODO: Add implementation details
\paragraph{Implementation Details}

% TODO: Summary of the suitability of the algorithm in the context of a Version Control System
\paragraph{Summary}


% ------------------------------------------------------------------------------

\subsection{Diffing}

% TODO: Explain what diffing is and why it is important in a VCS

% TODO: Fill in !important
\subsubsection{Longest Common Subsequence (LCS)}

% TODO: Add references
% Advantages and Disadvantages in the context of a Version Control System
% TODO: Fill in !important
\paragraph{Advantages}
% TODO: Fill in !important
\paragraph{Disadvantages}

% TODO: Add implementation details
\paragraph{Implementation Details}

% TODO: Summary of the suitability of the algorithm in the context of a Version Control System
\paragraph{Summary}


% TODO: Fill in !important
\subsubsection{Myers' Diff Algorithm}

% TODO: Add references
% Advantages and Disadvantages in the context of a Version Control System
% TODO: Fill in !important
\paragraph{Advantages}
% TODO: Fill in !important
\paragraph{Disadvantages}

% TODO: Add implementation details
\paragraph{Implementation Details}

% TODO: Summary of the suitability of the algorithm in the context of a Version Control System
\paragraph{Summary}


% ------------------------------------------------------------------------------

\subsection{Merging}

% TODO: Explain what merging is and why it is important in a VCS

% TODO: Fill in !important
\subsubsection{3-Way Merge}

% TODO: Add references
% Advantages and Disadvantages in the context of a Version Control System
% TODO: Fill in !important
\paragraph{Advantages}
% TODO: Fill in !important
\paragraph{Disadvantages}

% TODO: Add implementation details
\paragraph{Implementation Details}

% TODO: Summary of the suitability of the algorithm in the context of a Version Control System
\paragraph{Summary}


% TODO: Fill in !important
\subsubsection{Recursive Merge Algorithm}

% TODO: Add references
% Advantages and Disadvantages in the context of a Version Control System
% TODO: Fill in !important
\paragraph{Advantages}
% TODO: Fill in !important
\paragraph{Disadvantages}

% TODO: Add implementation details
\paragraph{Implementation Details}

% TODO: Summary of the suitability of the algorithm in the context of a Version Control System
\paragraph{Summary}

% ------------------------------------------------------------------------------